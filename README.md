# Проект: Визуализатор Минимального Остовного Дерева (MST)

## 1. Описание проекта

Данный проект представляет собой интерактивное Java-приложение для визуализации и анализа Минимальных Остовных Деревьев (MST). Приложение позволяет:

1. **Загружать** графы из `JSON` файлов.

2. **Строить** MST с использованием алгоритма Крускала.

3. **Симулировать сбой:** Интерактивно удалять случайное ребро из остова.

4. **Восстанавливать** остов: Находить минимальное по весу ребро для повторного соединения двух компонентов.

5. **Визуализировать** каждый шаг на графе.

6. **Сохранять (сериализовать)** текущее состояние MST обратно в `JSON`.

## 2. Технологии

* **Язык:** Java 17

* **Графический интерфейс (UI):** JavaFX 17

* **Сборка и зависимости:** Apache Maven

* **Работа с JSON:** Google Gson

## 3. Как запустить

### Необходимые компоненты

* **JDK 17** (Важно: проект настроен именно на 17-ю версию).

* **Apache Maven** (обычно встроен в IDE, например, IntelliJ IDEA).

### Инструкция по запуску

1. **Загрузите или клонируйте проект.**

2. **Структура папок:**

    * Убедитесь, что `pom.xml` находится в корне проекта.

    * Создайте папку `data` в корне проекта.

    * Поместите `JSON` файлы с вашими графами (например, `graph_demo.json`, `graph_simple.json`) в эту папку.

3. **Настройка IDE (Рекомендуется):**

    * В IntelliJ IDEA, откройте `File` -> `Settings` -> `Build, Execution, Deployment` -> `Maven`.

    * Установите **"JDK for importer"** и **"JDK for runner"** на вашу версию **JDK 17**.

4. **Запуск через терминал:**

    * Откройте терминал в корневой папке проекта.

    * Выполните команду:


mvn clean javafx:run


## 4. Архитектура и Дизайн

Проект построен на принципах ООП для гибкости и расширяемости.

### Модели данных

* `Graph.java`: Представляет исходный граф. Хранит количество вершин (`V`) и набор ребер (`Set<Edge>`).

* `Edge.java`: Представляет ребро. Хранит `src`, `dest` и `weight`. Реализует `Comparable` для сортировки по весу.

* `MST.java`: **Ключевой класс.** Представляет сам остов. Он хранит не только ребра (`mstEdges`), но и *вершины* (`vertices`), которые в него входят. Это позволяет корректно обрабатывать "одиночные" вершины, оставшиеся без ребер после разделения.

### Паттерн "Стратегия" (Strategy Pattern)

**Это ядро расширяемости проекта.**

* `MSTStrategy.java`: Это `interface` с одним методом `buildMST(Graph graph)`. Он определяет "контракт", который должен выполнить любой алгоритм построения MST.

* `KruskalMST.java`: **Текущая реализация** "Стратегии". Он строит MST с помощью алгоритма Крускала.

* **Зачем это нужно?** Если завтра мы захотим добавить **алгоритм Прима**, нам не придется менять существующий код. Мы просто создадим новый класс `PrimMST implements MSTStrategy` и реализуем в нем ту же логику.

### Алгоритмы

* **Алгоритм Крускала:** Реализован в `KruskalMST`. Он использует `DisjointSetUnion` для эффективного отслеживания компонентов и предотвращения циклов.

* `DisjointSetUnion.java`: Оптимизированная реализация Union-Find, использующая **сжатие пути (path compression)** и **объединение по рангу (union by rank)** для достижения почти постоянного времени выполнения операций `find` и `union`.

### Работа с JSON (Gson)

* **Загрузка (Десериализация):** При запуске (или выборе из `ComboBox`) `MainApp` читает `JSON` файл из папки `data/`, и `Gson` автоматически создает объект `Graph` из этого `JSON`.

* **Сохранение (Сериализация):** При нажатии кнопки "Сериализовать" `Gson` "превращает" *текущий* объект `currentMST` (со всеми его ребрами, вершинами и ссылкой на исходный `Graph`) в отформатированную `JSON`-строку и сохраняет ее в файл `mst_snapshot.json` в корне проекта.

## 5. Руководство пользователя (UI)

Интерфейс приложения состоит из панели управления, области визуализации и лога.

* **Выпадающий список (Граф:)**: Позволяет выбрать `JSON` файл из папки `data/`. Загрузка графа сбрасывает симуляцию.

* **Шаг 1: Построить MST**: Строит MST для загруженного графа, используя алгоритм Крускала.

* **Шаг 2: Удалить ребро**: Находит случайное ребро в "середине" остова (по индексу) и удаляет его. Визуально ребро становится красным пунктиром. MST разделяется на две компоненты.

* **Шаг 3: Найти и объединить**: Запускает поиск *во всем исходном графе* и находит ребро с минимальным весом, которое соединяет две разделенные компоненты. Добавляет это ребро (выделяется зеленым) в остов, восстанавливая его.

* **Сериализовать в JSON**: Сохраняет текущее состояние остова в `mst_snapshot.json`.

## 6. Расширяемость и Будущие улучшения

### Как добавить Алгоритм Прима

Благодаря паттерну "Стратегия", это очень просто:

1. **Создать класс:**


public class PrimMST implements MSTStrategy { @Override public Set<Edge> buildMST(Graph graph) { // ... Реализовать логику алгоритма Прима ... // (Например, используя PriorityQueue) // ... return mstResult; } }


2. **Интегрировать:** В `MainApp.java` можно было бы добавить `ComboBox` для выбора между `new KruskalMST()` и `new PrimMST()`.

### Идея: Адаптивный выбор (Sparse vs. Dense)

Это отличная идея для оптимизации, которую ты предложил.

* **Алгоритм Крускала** (наш) имеет сложность $O(E \log E)$ или $O(E \log V)$ (из-за сортировки ребер). Он идеален для **разреженных графов (sparse graphs)**, где E (ребра) близки к V (вершины).

* **Алгоритм Прима** (с использованием Фибоначчиевой кучи) имеет сложность $O(E + V \log V)$. Он показывает себя лучше на **плотных графах (dense graphs)**, где E близко к $V^2$.

**Как это можно реализовать:**

Можно создать класс-менеджер (например, `MSTBuilder`), который бы анализировал граф перед построением:


public class MSTBuilder {

public MSTStrategy getBestStrategy(Graph graph) {
int V = graph.getV();
int E = graph.getEdges().size();

    // Пороговое значение плотности (нужно подобрать экспериментально)
    // Например, если ребер больше, чем V * log(V)
    double densityThreshold = V * Math.log(V); 

    if (E > densityThreshold) {
        // Граф плотный -> Используем Прима
        return new PrimMST(); 
    } else {
        // Граф разреженный -> Используем Краскала
        return new KruskalMST();
    }
}

// В MainApp мы бы вызывали:
// MSTBuilder builder = new MSTBuilder();
// MSTStrategy strategy = builder.getBestStrategy(mainGraph);
// Set<Edge> mstEdges = strategy.buildMST(mainGraph);

}


Текущая архитектура проекта полностью готова к такому расширению.
